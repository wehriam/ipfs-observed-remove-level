{"version":3,"sources":["../../src/map.js"],"names":["ObservedRemoveMap","parser","jsonStreamParser","CID","streamArray","jsonStreamArray","hash32","PQueue","LruCache","Readable","debounce","SerializeTransform","DeserializeTransform","ReadableJsonDump","notSubscribedRegex","OPEN_BUFFER","Buffer","from","MID_BUFFER","CLOSE_BUFFER","COMMA_BUFFER","IpfsObservedRemoveMap","constructor","db","ipfs","topic","entries","options","Error","chunkPubSub","abortController","AbortController","active","disableSync","boundHandleQueueMessage","handleQueueMessage","bind","boundHandleHashMessage","handleHashMessage","readyPromise","then","initIpfs","syncCache","peersCache","max","maxAge","hasNewPeers","on","ipfsHashes","ipfsHash","debouncedIpfsSync","ipfsSync","serializeTransform","autoDestroy","maxChunkSize","messageSlice","publishQueue","add","controller","cleanup","createLinkedAbortController","pubsub","publish","signal","error","type","emit","deserializeTransform","timeout","message","inboundQueue","queue","JSON","parse","toString","process","hashLoadQueue","concurrency","aborted","abort","handler","addEventListener","removeEventListener","id","ipfsId","stringify","write","subscribe","waitForPeersThenSendHash","waitForPeers","peerIds","peers","length","name","Promise","resolve","setTimeout","handleAbort","clearTimeout","queueMicrotask","code","hashes","getIpfsHashes","hash","has","set","getIpfsHash","stream","namespace","file","wrapWithDirectory","recursive","pin","cid","namespaceLength","isAdded","isFirstInsertion","isFirstDeletion","streams","read","addPromises","cleanupFunctions","push","namespaceWithKey","pair","iterator","gt","lt","keyAsBuffer","valueAsBuffer","key","slice","streamId","namespaceWithId","all","map","ipfsPeerCount","shutdown","unsubscribeAbortController","unsubscribe","test","onIdle","destroy","data","remoteHash","loadIpfsHash","cat","pipeline","pipe","arrayDepth","streamState","insertions","deletions","recentChunks","MAX_CHUNK_HISTORY","value","i","d","reject","chunk","shift","enhancedMessage","combinedChunks","concat","chunkStr","contextLength","Math","min","context","enhancedError","stack"],"mappings":"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","sourcesContent":["// @flow\n\nimport ObservedRemoveMap from 'observed-remove-level/map';\nimport { parser as jsonStreamParser } from 'stream-json/Parser';\nimport CID from 'cids';\nimport { streamArray as jsonStreamArray } from 'stream-json/streamers/StreamArray';\nimport { hash32 } from 'farmhash';\nimport PQueue from 'p-queue';\nimport LruCache from 'lru-cache';\nimport { Readable } from 'stream';\nimport debounce from 'lodash/debounce';\nimport {\n  SerializeTransform,\n  DeserializeTransform,\n} from '@bunchtogether/chunked-stream-transformers';\nimport ReadableJsonDump from './readable-json-dump';\n\n\ntype Options = {\n  maxAge?:number,\n  bufferPublishing?:number,\n  namespace?: string,\n  format?: string,\n  disableSync?: boolean,\n  chunkPubSub?: boolean\n};\n\nconst notSubscribedRegex = /Not subscribed/;\n\nconst OPEN_BUFFER = Buffer.from('[\"');\nconst MID_BUFFER = Buffer.from('\",');\nconst CLOSE_BUFFER = Buffer.from(']');\nconst COMMA_BUFFER = Buffer.from(',');\n\nexport default class IpfsObservedRemoveMap<V> extends ObservedRemoveMap<V> { // eslint-disable-line no-unused-vars\n  /**\n   * Create an observed-remove CRDT.\n   * @param {Object} [ipfs] Object implementing the [core IPFS API](https://github.com/ipfs/interface-ipfs-core#api), most likely a [js-ipfs](https://github.com/ipfs/js-ipfs) or [ipfs-http-client](https://github.com/ipfs/js-ipfs-http-client) object.\n   * @param {String} [topic] IPFS pubub topic to use in synchronizing the CRDT.\n   * @param {Iterable<V>} [entries=[]] Iterable of initial values\n   * @param {Object} [options={}]\n   * @param {String} [options.maxAge=5000] Max age of insertion/deletion identifiers\n   * @param {String} [options.bufferPublishing=20] Interval by which to buffer 'publish' events\n   * @param {boolean} [options.chunkPubSub=false] Chunk pubsub messages for values greater than 1 MB\n   */\n  constructor(db:Object, ipfs:Object, topic:string, entries?: Iterable<[string, V]>, options?:Options = {}) {\n    super(db, entries, options);\n    if (!ipfs) {\n      throw new Error(\"Missing required argument 'ipfs'\");\n    }\n    this.chunkPubSub = !!options.chunkPubSub;\n    this.db = db;\n    this.ipfs = ipfs;\n    this.abortController = new AbortController();\n    this.topic = topic;\n    this.active = true;\n    this.disableSync = !!options.disableSync;\n    this.boundHandleQueueMessage = this.handleQueueMessage.bind(this);\n    this.boundHandleHashMessage = this.handleHashMessage.bind(this);\n    this.readyPromise = this.readyPromise.then(async () => {\n      await this.initIpfs();\n    });\n    this.syncCache = new LruCache(100);\n    this.peersCache = new LruCache({\n      max: 100,\n      maxAge: 1000 * 60 * 60,\n    });\n    this.hasNewPeers = false;\n    this.on('set', () => {\n      delete this.ipfsHashes;\n      delete this.ipfsHash;\n    });\n    this.on('delete', () => {\n      delete this.ipfsHashes;\n      delete this.ipfsHash;\n    });\n    this.debouncedIpfsSync = debounce(this.ipfsSync.bind(this), 1000);\n    this.serializeTransform = new SerializeTransform({\n      autoDestroy: false,\n      maxChunkSize: 1024 * 512,\n    });\n    this.serializeTransform.on('data', (messageSlice) => {\n      if (!this.active) {\n        return;\n      }\n      this.publishQueue.add(async () => {\n        if (!this.active) {\n          return;\n        }\n        const { controller, cleanup } = this.createLinkedAbortController();\n        try {\n          await this.ipfs.pubsub.publish(this.topic, messageSlice, { signal: controller.signal });\n        } catch (error) {\n          if (error.type !== 'aborted') {\n            this.emit('error', error);\n          }\n        } finally {\n          cleanup();\n        }\n      });\n    });\n    this.serializeTransform.on('error', (error) => {\n      this.emit('error', error);\n    });\n    this.deserializeTransform = new DeserializeTransform({\n      autoDestroy: false,\n      timeout: 10000,\n    });\n    this.deserializeTransform.on('error', (error) => {\n      this.emit('error', error);\n    });\n    this.deserializeTransform.on('data', (message) => {\n      this.inboundQueue.add(async () => {\n        try {\n          const queue = JSON.parse(message.toString('utf8'));\n          await this.process(queue);\n        } catch (error) {\n          this.emit('error', error);\n        }\n      });\n    });\n    this.hashLoadQueue = new PQueue({ concurrency: 2 });\n    this.publishQueue = new PQueue({ concurrency: 1 });\n    this.inboundQueue = new PQueue({ concurrency: 1 });\n    this.hashLoadQueue.on('idle', async () => {\n      if (this.hasNewPeers && this.active) {\n        this.debouncedIpfsSync();\n      }\n      this.emit('hashesloaded');\n    });\n  }\n\n  /**\n   * Resolves when IPFS topic subscriptions are confirmed.\n   *\n   * @name IpfsObservedRemoveSet#readyPromise\n   * @type {Promise<void>}\n   * @readonly\n   */\n\n  declare ipfs: Object;\n  declare topic: string;\n  declare readyPromise: Promise<void>;\n  declare active: boolean;\n  declare ipfsId: string;\n  declare disableSync: boolean;\n  declare boundHandleQueueMessage: (message:{from:string, data:Buffer}) => void;\n  declare boundHandleHashMessage: (message:{from:string, data:Buffer}) => Promise<void>;\n  declare db: Object;\n  declare ipfsHashes: Array<string> | void;\n  declare ipfsHash: string | void;\n  declare syncCache: LruCache;\n  declare peersCache: LruCache;\n  declare hasNewPeers: boolean;\n  declare debouncedIpfsSync: () => Promise<void>;\n  declare abortController: AbortController;\n  declare chunkPubSub: boolean;\n  declare serializeTransform: SerializeTransform;\n  declare deserializeTransform: DeserializeTransform;\n  declare hashLoadQueue: PQueue;\n  declare publishQueue: PQueue;\n  declare inboundQueue: PQueue;\n\n  /**\n   * Create a per-operation abort controller linked to the main abort controller.\n   * This prevents listener accumulation in any-signal when combining signals.\n   * @private\n   * @returns {{controller: AbortController, cleanup: Function}}\n   */\n  createLinkedAbortController(): { controller: AbortController, cleanup: () => void } {\n    const controller = new AbortController();\n    let cleanup = () => {};\n\n    if (this.abortController.signal.aborted) {\n      controller.abort();\n    } else {\n      const handler = () => controller.abort();\n      this.abortController.signal.addEventListener('abort', handler);\n      cleanup = () => {\n        this.abortController.signal.removeEventListener('abort', handler);\n      };\n    }\n\n    return { controller, cleanup };\n  }\n\n  async initIpfs() {\n    try {\n      const { id } = await this.ipfs.id({ signal: this.abortController.signal });\n      this.ipfsId = id;\n    } catch (error) {\n      if (error.type !== 'aborted') {\n        throw error;\n      }\n      return;\n    }\n    this.on('publish', (queue) => {\n      if (!this.active) {\n        return;\n      }\n      this.publishQueue.add(async () => {\n        if (!this.active) {\n          return;\n        }\n        const message = Buffer.from(JSON.stringify(queue));\n        if (this.chunkPubSub) {\n          this.serializeTransform.write(message);\n        } else {\n          const { controller, cleanup } = this.createLinkedAbortController();\n          try {\n            await this.ipfs.pubsub.publish(this.topic, message, { signal: controller.signal });\n          } catch (error) {\n            if (error.type !== 'aborted') {\n              this.emit('error', error);\n            }\n          } finally {\n            cleanup();\n          }\n        }\n      });\n    });\n    try {\n      await this.ipfs.pubsub.subscribe(this.topic, this.boundHandleQueueMessage, { signal: this.abortController.signal });\n      if (!this.disableSync) {\n        await this.ipfs.pubsub.subscribe(`${this.topic}:hash`, this.boundHandleHashMessage, { signal: this.abortController.signal });\n        this.waitForPeersThenSendHash();\n      }\n    } catch (error) {\n      if (error.type !== 'aborted') {\n        throw error;\n      }\n    }\n  }\n\n  async waitForPeers():Promise<void> {\n    while (true) {\n      const { controller, cleanup } = this.createLinkedAbortController();\n      try {\n        const peerIds = await this.ipfs.pubsub.peers(this.topic, { timeout: 10000, signal: controller.signal });\n        if (this.abortController.signal.aborted) {\n          return;\n        }\n        if (peerIds.length > 0) {\n          break;\n        }\n      } catch (error) {\n        if (error.name === 'TimeoutError') {\n          continue;\n        }\n        throw error;\n      } finally {\n        cleanup();\n      }\n    }\n    while (true) {\n      const { controller, cleanup } = this.createLinkedAbortController();\n      try {\n        const peerIds = await this.ipfs.pubsub.peers(`${this.topic}:hash`, { timeout: 10000, signal: controller.signal });\n        if (this.abortController.signal.aborted) {\n          return;\n        }\n        if (peerIds.length > 0) {\n          break;\n        }\n      } catch (error) {\n        if (error.name === 'TimeoutError') {\n          continue;\n        }\n        throw error;\n      } finally {\n        cleanup();\n      }\n    }\n  }\n\n  async waitForPeersThenSendHash():Promise<void> {\n    if (!this.active) {\n      return;\n    }\n    const { controller, cleanup } = this.createLinkedAbortController();\n    try {\n      const peerIds = await this.ipfs.pubsub.peers(this.topic, { timeout: 10000, signal: controller.signal });\n      if (this.abortController.signal.aborted) {\n        return;\n      }\n      if (peerIds.length > 0) {\n        this.debouncedIpfsSync();\n      } else {\n        await new Promise((resolve) => {\n          const timeout = setTimeout(() => {\n            this.abortController.signal.removeEventListener('abort', handleAbort);\n            resolve();\n          }, 10000);\n          const handleAbort = () => {\n            clearTimeout(timeout);\n            this.abortController.signal.removeEventListener('abort', handleAbort);\n            resolve();\n          };\n          this.abortController.signal.addEventListener('abort', handleAbort);\n        });\n        queueMicrotask(() => {\n          this.waitForPeersThenSendHash();\n        });\n      }\n    } catch (error) {\n      // IPFS connection is closed or timed out, don't send join\n      if (error.type !== 'aborted' && error.code !== 'ECONNREFUSED' && error.name !== 'TimeoutError') {\n        this.emit('error', error);\n      }\n      if (this.active && error.name === 'TimeoutError') {\n        queueMicrotask(() => {\n          this.waitForPeersThenSendHash();\n        });\n      }\n    } finally {\n      cleanup();\n    }\n  }\n\n  /**\n   * Publish an IPFS hash of an array containing all of the object's insertions and deletions.\n   * @return {Array<Array<any>>}\n   */\n  async ipfsSync() {\n    if (!this.active) {\n      return;\n    }\n    try {\n      const hashes = await this.getIpfsHashes();\n      for (const hash of hashes) {\n        if (!this.active) {\n          return;\n        }\n        if (!this.syncCache.has(hash) || this.hasNewPeers) {\n          this.syncCache.set(hash, true);\n          const { controller, cleanup } = this.createLinkedAbortController();\n          try {\n            await this.ipfs.pubsub.publish(`${this.topic}:hash`, Buffer.from(hash, 'utf8'), { signal: controller.signal });\n            this.emit('hash', hash);\n          } finally {\n            cleanup();\n          }\n        }\n      }\n      this.hasNewPeers = false;\n    } catch (error) {\n      if (error.type !== 'aborted') {\n        this.emit('error', error);\n      }\n    }\n  }\n\n  /**\n   * Stores and returns an IPFS hash of the current insertions and deletions\n   * @return {Promise<string>}\n   */\n  async getIpfsHash():Promise<string> {\n    if (this.ipfsHash) {\n      return this.ipfsHash;\n    }\n    const stream = new ReadableJsonDump(this.db.db.db, this.namespace);\n    const { controller, cleanup } = this.createLinkedAbortController();\n    try {\n      const file = await this.ipfs.add(stream, { wrapWithDirectory: false, recursive: false, pin: false, signal: controller.signal });\n      this.ipfsHash = file.cid.toString();\n      return this.ipfsHash;\n    } finally {\n      cleanup();\n    }\n  }\n\n  /**\n   * Stores and returns an IPFS hash of the current insertions and deletions\n   * @return {Promise<string>}\n   */\n  async getIpfsHashes():Promise<Array<string>> {\n    if (this.ipfsHashes) {\n      return this.ipfsHashes;\n    }\n    const namespaceLength = Buffer.from(`${this.namespace}>`).length;\n    const isAdded = [\n      false,\n      false,\n      false,\n      false,\n      false,\n      false,\n      false,\n      false,\n    ];\n    const isFirstInsertion = [\n      true,\n      true,\n      true,\n      true,\n      true,\n      true,\n      true,\n      true,\n    ];\n    const isFirstDeletion = [\n      true,\n      true,\n      true,\n      true,\n      true,\n      true,\n      true,\n      true,\n    ];\n    const streams = [\n      new Readable({ read() {}, signal: this.abortController.signal }),\n      new Readable({ read() {}, signal: this.abortController.signal }),\n      new Readable({ read() {}, signal: this.abortController.signal }),\n      new Readable({ read() {}, signal: this.abortController.signal }),\n      new Readable({ read() {}, signal: this.abortController.signal }),\n      new Readable({ read() {}, signal: this.abortController.signal }),\n      new Readable({ read() {}, signal: this.abortController.signal }),\n      new Readable({ read() {}, signal: this.abortController.signal }),\n    ];\n    const addPromises = [];\n    const cleanupFunctions = [];\n    for (const stream of streams) {\n      stream.push(Buffer.from('[['));\n    }\n    for await (const [namespaceWithKey, pair] of this.db.db.db.iterator({ gt: `${this.namespace}>`, lt: `${this.namespace}?`, keyAsBuffer: true, valueAsBuffer: true })) {\n      const key = namespaceWithKey.slice(namespaceLength);\n      const streamId = hash32(key) % 8;\n      const stream = streams[streamId];\n      if (!isAdded[streamId]) {\n        isAdded[streamId] = true;\n        const { controller, cleanup } = this.createLinkedAbortController();\n        cleanupFunctions.push(cleanup);\n        addPromises.push(this.ipfs.add(stream, { wrapWithDirectory: false, recursive: false, pin: false, signal: controller.signal }));\n      }\n      if (isFirstInsertion[streamId]) {\n        isFirstInsertion[streamId] = false;\n      } else {\n        stream.push(COMMA_BUFFER);\n      }\n      stream.push(OPEN_BUFFER);\n      stream.push(key);\n      stream.push(MID_BUFFER);\n      stream.push(pair);\n      stream.push(CLOSE_BUFFER);\n    }\n    for (const stream of streams) {\n      stream.push(Buffer.from('],['));\n    }\n    for await (const [namespaceWithId, key] of this.db.db.db.iterator({ gt: `${this.namespace}<`, lt: `${this.namespace}=`, keyAsBuffer: true, valueAsBuffer: true })) {\n      const id = namespaceWithId.slice(namespaceLength);\n      const streamId = hash32(key) % 8;\n      const stream = streams[streamId];\n      if (!isAdded[streamId]) {\n        isAdded[streamId] = true;\n        const { controller, cleanup } = this.createLinkedAbortController();\n        cleanupFunctions.push(cleanup);\n        addPromises.push(this.ipfs.add(stream, { wrapWithDirectory: false, recursive: false, pin: false, signal: controller.signal }));\n      }\n      if (isFirstDeletion[streamId]) {\n        isFirstDeletion[streamId] = false;\n      } else {\n        stream.push(COMMA_BUFFER);\n      }\n      stream.push(OPEN_BUFFER);\n      stream.push(id);\n      stream.push(MID_BUFFER);\n      stream.push(key);\n      stream.push(CLOSE_BUFFER);\n    }\n    for (const stream of streams) {\n      stream.push(Buffer.from(']]'));\n    }\n    for (const stream of streams) {\n      stream.push(null);\n    }\n    try {\n      const hashes = (await Promise.all(addPromises)).map(({ cid }) => cid.toString());\n      this.ipfsHashes = hashes;\n      return hashes;\n    } finally {\n      for (const cleanup of cleanupFunctions) {\n        cleanup();\n      }\n    }\n  }\n\n\n  //  /**\n  //   * Stores and returns an IPFS hash of the current insertions and deletions\n  //   * @return {Promise<string>}\n  //   */\n  //  async getIpfsHashes():Promise<Array<string>> {\n  //    if (this.ipfsHashes) {\n  //      return this.ipfsHashes;\n  //    }\n  //    const start = Date.now();\n  //    const ipfsHashes = [];\n  //    for (let i = 0; i < 8; i += 1) {\n  //      const stream = new ReadableJsonDump(this.db.db.db, this.namespace, { buckets: 8, bucket: i });\n  //      const file = await this.ipfs.add(stream, { wrapWithDirectory: false, recursive: false, pin: false, signal: this.abortController.signal });\n  //      ipfsHashes.push(file.cid.toString());\n  //      if (!this.active) {\n  //        break;\n  //      }\n  //    }\n  //    console.log('DUMP', Date.now() - start, this.ipfsId);\n  //    console.log(ipfsHashes)\n  //    this.ipfsHashes = ipfsHashes;\n  //    return ipfsHashes;\n  //  }\n\n  /**\n   * Current number of IPFS pubsub peers.\n   * @return {number}\n   */\n  async ipfsPeerCount():Promise<number> {\n    const { controller, cleanup } = this.createLinkedAbortController();\n    try {\n      const peerIds = await this.ipfs.pubsub.peers(this.topic, { signal: controller.signal });\n      return peerIds.length;\n    } finally {\n      cleanup();\n    }\n  }\n\n  /**\n   * Gracefully shutdown\n   * @return {void}\n   */\n  async shutdown(): Promise<void> {\n    this.active = false;\n    // Catch exceptions here as pubsub is sometimes closed by process kill signals.\n    if (this.ipfsId) {\n      try {\n        const unsubscribeAbortController = new AbortController();\n        const timeout = setTimeout(() => {\n          unsubscribeAbortController.abort();\n        }, 5000);\n        await this.ipfs.pubsub.unsubscribe(this.topic, this.boundHandleQueueMessage, { signal: unsubscribeAbortController.signal });\n        if (!this.disableSync) {\n          await this.ipfs.pubsub.unsubscribe(`${this.topic}:hash`, this.boundHandleHashMessage, { signal: unsubscribeAbortController.signal });\n        }\n        clearTimeout(timeout);\n      } catch (error) {\n        if (!notSubscribedRegex.test(error.message)) {\n          this.abortController.abort();\n          this.abortController = new AbortController();\n          throw error;\n        }\n      }\n    }\n    await this.publishQueue.onIdle();\n    await this.inboundQueue.onIdle();\n    await this.hashLoadQueue.onIdle();\n    this.abortController.abort();\n    this.abortController = new AbortController();\n    await this.deserializeTransform.onIdle();\n    this.serializeTransform.destroy();\n    this.deserializeTransform.destroy();\n    await super.shutdown();\n  }\n\n  handleQueueMessage(message:{from:string, data:Buffer}) {\n    if (message.from === this.ipfsId) {\n      return;\n    }\n    if (!this.active) {\n      return;\n    }\n    if (this.chunkPubSub) {\n      this.deserializeTransform.write(message.data);\n    } else {\n      this.inboundQueue.add(async () => {\n        try {\n          const queue = JSON.parse(Buffer.from(message.data).toString('utf8'));\n          await this.process(queue);\n        } catch (error) {\n          this.emit('error', error);\n        }\n      });\n    }\n  }\n\n  handleHashMessage(message:{from:string, data:Buffer}) {\n    if (!this.active) {\n      return;\n    }\n    if (message.from === this.ipfsId) {\n      return;\n    }\n    if (!this.peersCache.has(message.from)) {\n      this.hasNewPeers = true;\n      this.peersCache.set(message.from, true);\n    }\n    const remoteHash = Buffer.from(message.data).toString('utf8');\n    if (this.syncCache.has(remoteHash)) {\n      return;\n    }\n    this.syncCache.set(remoteHash, true);\n    try {\n      this.hashLoadQueue.add(() => this.loadIpfsHash(remoteHash));\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n  async loadIpfsHash(hash:string) {\n    // $FlowFixMe\n    const stream = Readable.from(this.ipfs.cat(new CID(hash), { timeout: 120000 }));\n    const parser = jsonStreamParser();\n    const streamArray = jsonStreamArray();\n    const pipeline = stream.pipe(parser);\n    let arrayDepth = 0;\n    let streamState = 0;\n    let insertions = [];\n    let deletions = [];\n    const recentChunks = [];\n    const MAX_CHUNK_HISTORY = 5;\n    streamArray.on('data', ({ value }) => {\n      if (streamState === 1) {\n        insertions.push(value);\n      } else if (streamState === 3) {\n        deletions.push(value);\n      }\n      if (insertions.length + deletions.length < 1000) {\n        return;\n      }\n      const i = insertions;\n      const d = deletions;\n      insertions = [];\n      deletions = [];\n      this.inboundQueue.add(async () => {\n        await this.process([i, d], true);\n      });\n    });\n    try {\n      await new Promise((resolve, reject) => {\n        stream.on('data', (chunk) => {\n          // Track recent raw chunks for error reporting\n          recentChunks.push(chunk);\n          if (recentChunks.length > MAX_CHUNK_HISTORY) {\n            recentChunks.shift();\n          }\n        });\n        stream.on('error', (error) => {\n          reject(error);\n        });\n        streamArray.on('error', (error) => {\n          reject(error);\n        });\n        pipeline.on('error', (error) => {\n          // Enhance error message with the problematic chunk\n          let enhancedMessage = error.message;\n          if (recentChunks.length > 0) {\n            // Concatenate recent chunks and show the problematic section\n            const combinedChunks = Buffer.concat(recentChunks);\n            const chunkStr = combinedChunks.toString('utf8');\n            // Show last 200 characters to give context\n            const contextLength = Math.min(200, chunkStr.length);\n            const context = chunkStr.slice(-contextLength);\n            enhancedMessage += `\\nProblematic chunk (last ${contextLength} chars): ${JSON.stringify(context)}`;\n          }\n          const enhancedError = new Error(enhancedMessage);\n          enhancedError.stack = error.stack;\n\n          // Emit warning but continue processing what we successfully parsed\n          this.emit('warning', enhancedError);\n\n          // Resolve instead of reject to continue processing\n          resolve();\n        });\n        pipeline.on('end', () => {\n          resolve();\n        });\n        pipeline.on('data', (data) => {\n          const { name } = data;\n          if (name === 'startArray') {\n            arrayDepth += 1;\n            if (arrayDepth === 2) {\n              streamState += 1;\n            }\n          }\n          if (streamState === 1 || streamState === 3) {\n            streamArray.write(data);\n          }\n          if (name === 'endArray') {\n            if (arrayDepth === 2) {\n              streamState += 1;\n            }\n            arrayDepth -= 1;\n          }\n        });\n      });\n    } catch (error) {\n      if (error.type !== 'aborted') {\n        this.emit('error', error);\n      }\n      return;\n    }\n    stream.destroy();\n    await this.inboundQueue.add(async () => {\n      await this.process([insertions, deletions]);\n    });\n    await this.inboundQueue.onIdle();\n  }\n}\n"],"file":"map.js"}