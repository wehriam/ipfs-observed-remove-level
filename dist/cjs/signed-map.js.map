{"version":3,"sources":["../../src/signed-map.js"],"names":["SerializeTransform","DeserializeTransform","require","notSubscribedRegex","IpfsSignedObservedRemoveMap","SignedObservedRemoveMap","constructor","db","ipfs","topic","entries","options","Error","chunkPubSub","abortController","AbortController","signal","active","disableSync","boundHandleQueueMessage","handleQueueMessage","bind","boundHandleHashMessage","handleHashMessage","readyPromise","then","initIpfs","syncCache","LruCache","peersCache","max","maxAge","hasNewPeers","on","ipfsHash","debouncedIpfsSync","ipfsSync","serializeTransform","autoDestroy","maxChunkSize","messageSlice","controller","cleanup","createLinkedAbortController","pubsub","publish","error","type","emit","deserializeTransform","timeout","message","queue","JSON","parse","toString","processSigned","hashLoadQueue","PQueue","aborted","abort","handler","addEventListener","removeEventListener","id","ipfsId","Buffer","from","stringify","write","subscribe","discover","waitForPeersThenSendHash","peerIds","peers","length","Promise","resolve","setTimeout","queueMicrotask","code","name","hash","getIpfsHash","has","set","data","dump","file","add","wrapWithDirectory","recursive","pin","cid","ipfsPeerCount","shutdown","unsubscribeAbortController","unsubscribe","clearTimeout","test","onIdle","destroy","remoteHash","loadIpfsHash","stream","Readable","cat","CID","parser","streamArray","pipeline","pipe","arrayDepth","streamState","insertions","deletions","value","push","i","d","reject","signedProcessQueue"],"mappings":"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","sourcesContent":["// @flow\n\nimport SignedObservedRemoveMap from 'observed-remove-level/signed-map';\nimport { parser as jsonStreamParser } from 'stream-json/Parser';\nimport CID from 'cids';\n\nimport { streamArray as jsonStreamArray } from 'stream-json/streamers/StreamArray';\nimport PQueue from 'p-queue';\nimport LruCache from 'lru-cache';\nimport debounce from 'lodash/debounce';\nimport { Readable } from 'stream';\n// $FlowFixMe - setMaxListeners is available in Node.js 15.4+\nimport { setMaxListeners } from 'events';\n\nconst { SerializeTransform, DeserializeTransform } = require('@bunchtogether/chunked-stream-transformers');\n\ntype Options = {\n  maxAge?:number,\n  bufferPublishing?:number,\n  namespace?: string,\n  key: any,\n  format?: string,\n  disableSync?: boolean,\n  chunkPubSub?: boolean\n};\n\nconst notSubscribedRegex = /Not subscribed/;\n\nexport default class IpfsSignedObservedRemoveMap<V> extends SignedObservedRemoveMap<V> { // eslint-disable-line no-unused-vars\n  /**\n   * Create an observed-remove CRDT.\n   * @param {Object} [ipfs] Object implementing the [core IPFS API](https://github.com/ipfs/interface-ipfs-core#api), most likely a [js-ipfs](https://github.com/ipfs/js-ipfs) or [ipfs-http-client](https://github.com/ipfs/js-ipfs-http-client) object.\n   * @param {String} [topic] IPFS pubub topic to use in synchronizing the CRDT.\n   * @param {Iterable<V>} [entries=[]] Iterable of initial values\n   * @param {Object} [options={}]\n   * @param {String} [options.maxAge=5000] Max age of insertion/deletion identifiers\n   * @param {String} [options.bufferPublishing=20] Interval by which to buffer 'publish' events\n   * @param {boolean} [options.chunkPubSub=false] Chunk pubsub messages for values greater than 1 MB\n   */\n  constructor(db:Object, ipfs:Object, topic:string, entries?: Iterable<[string, V, string, string]>, options?:Options = {}) {\n    super(db, entries, options);\n    if (!ipfs) {\n      throw new Error(\"Missing required argument 'ipfs'\");\n    }\n    this.chunkPubSub = !!options.chunkPubSub;\n    this.db = db;\n    this.ipfs = ipfs;\n    this.abortController = new AbortController();\n    setMaxListeners(1000, this.abortController.signal);\n    this.topic = topic;\n    this.active = true;\n    this.disableSync = !!options.disableSync;\n    this.boundHandleQueueMessage = this.handleQueueMessage.bind(this);\n    this.boundHandleHashMessage = this.handleHashMessage.bind(this);\n    this.readyPromise = this.readyPromise.then(async () => {\n      await this.initIpfs();\n    });\n    this.syncCache = new LruCache(100);\n    this.peersCache = new LruCache({\n      max: 100,\n      maxAge: 1000 * 60,\n    });\n    this.hasNewPeers = false;\n    this.on('set', () => {\n      delete this.ipfsHash;\n    });\n    this.on('delete', () => {\n      delete this.ipfsHash;\n    });\n    this.debouncedIpfsSync = debounce(this.ipfsSync.bind(this), 1000);\n    this.serializeTransform = new SerializeTransform({\n      autoDestroy: false,\n      maxChunkSize: 1024 * 512,\n    });\n    this.serializeTransform.on('data', async (messageSlice) => {\n      if (!this.active) {\n        return;\n      }\n      const { controller, cleanup } = this.createLinkedAbortController();\n      try {\n        await this.ipfs.pubsub.publish(this.topic, messageSlice, { signal: controller.signal });\n      } catch (error) {\n        if (error.type !== 'aborted' && this.active) {\n          this.emit('error', error);\n        }\n      } finally {\n        cleanup();\n      }\n    });\n    this.serializeTransform.on('error', (error) => {\n      this.emit('error', error);\n    });\n    this.deserializeTransform = new DeserializeTransform({\n      autoDestroy: false,\n      timeout: 10000,\n    });\n    this.deserializeTransform.on('error', (error) => {\n      this.emit('error', error);\n    });\n    this.deserializeTransform.on('data', async (message) => {\n      try {\n        const queue = JSON.parse(message.toString('utf8'));\n        await this.processSigned(queue);\n      } catch (error) {\n        this.emit('error', error);\n      }\n    });\n    this.hashLoadQueue = new PQueue({});\n    this.hashLoadQueue.on('idle', async () => {\n      if (this.hasNewPeers && this.active) {\n        this.debouncedIpfsSync();\n      }\n      this.emit('hashesloaded');\n    });\n  }\n\n  /**\n   * Resolves when IPFS topic subscriptions are confirmed.\n   *\n   * @name IpfsObservedRemoveSet#readyPromise\n   * @type {Promise<void>}\n   * @readonly\n   */\n\n  declare ipfs: Object;\n  declare topic: string;\n  declare readyPromise: Promise<void>;\n  declare active: boolean;\n  declare ipfsId: string;\n  declare disableSync: boolean;\n  declare boundHandleQueueMessage: (message:{from:string, data:Buffer}) => Promise<void>;\n  declare boundHandleHashMessage: (message:{from:string, data:Buffer}) => Promise<void>;\n  declare db: Object;\n  declare ipfsHash: string | void;\n  declare syncCache: LruCache;\n  declare peersCache: LruCache;\n  declare hasNewPeers: boolean;\n  declare debouncedIpfsSync: () => Promise<void>;\n  declare abortController: AbortController;\n  declare chunkPubSub: boolean;\n  declare serializeTransform: SerializeTransform;\n  declare deserializeTransform: DeserializeTransform;\n  declare hashLoadQueue: PQueue;\n\n  /**\n   * Create a per-operation abort controller linked to the main abort controller.\n   * This prevents listener accumulation in any-signal when combining signals.\n   * @private\n   * @returns {{controller: AbortController, cleanup: Function}}\n   */\n  createLinkedAbortController(): { controller: AbortController, cleanup: () => void } {\n    const controller = new AbortController();\n    let cleanup = () => {};\n\n    if (this.abortController.signal.aborted) {\n      controller.abort();\n    } else {\n      const handler = () => controller.abort();\n      this.abortController.signal.addEventListener('abort', handler);\n      cleanup = () => {\n        this.abortController.signal.removeEventListener('abort', handler);\n      };\n    }\n\n    return { controller, cleanup };\n  }\n\n  async initIpfs() {\n    try {\n      const { id } = await this.ipfs.id({ signal: this.abortController.signal });\n      this.ipfsId = id;\n    } catch (error) {\n      if (error.type !== 'aborted' && this.active) {\n        throw error;\n      }\n      return;\n    }\n    this.on('publish', async (queue) => {\n      if (!this.active) {\n        return;\n      }\n      if (this.chunkPubSub) {\n        const message = Buffer.from(JSON.stringify(queue));\n        this.serializeTransform.write(message);\n      } else {\n        const { controller, cleanup } = this.createLinkedAbortController();\n        try {\n          const message = Buffer.from(JSON.stringify(queue));\n          await this.ipfs.pubsub.publish(this.topic, message, { signal: controller.signal });\n        } catch (error) {\n          if (error.type !== 'aborted' && this.active) {\n            this.emit('error', error);\n          }\n        } finally {\n          cleanup();\n        }\n      }\n    });\n    try {\n      await this.ipfs.pubsub.subscribe(this.topic, this.boundHandleQueueMessage, { discover: true, signal: this.abortController.signal });\n      if (!this.disableSync) {\n        await this.ipfs.pubsub.subscribe(`${this.topic}:hash`, this.boundHandleHashMessage, { discover: true, signal: this.abortController.signal });\n        this.waitForPeersThenSendHash();\n      }\n    } catch (error) {\n      if (error.type !== 'aborted' && this.active) {\n        throw error;\n      }\n    }\n  }\n\n  async waitForPeersThenSendHash():Promise<void> {\n    if (!this.active) {\n      return;\n    }\n\n    const { controller, cleanup } = this.createLinkedAbortController();\n    try {\n      const peerIds = await this.ipfs.pubsub.peers(this.topic, { timeout: 10000, signal: controller.signal });\n      if (peerIds.length > 0) {\n        this.debouncedIpfsSync();\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 10000));\n        queueMicrotask(() => {\n          this.waitForPeersThenSendHash();\n        });\n      }\n    } catch (error) {\n      // IPFS connection is closed or timed out, don't send join\n      if (error.type !== 'aborted' && error.code !== 'ECONNREFUSED' && error.name !== 'TimeoutError') {\n        this.emit('error', error);\n      }\n      if (this.active && error.name === 'TimeoutError') {\n        queueMicrotask(() => {\n          this.waitForPeersThenSendHash();\n        });\n      }\n    } finally {\n      cleanup();\n    }\n  }\n\n  /**\n   * Publish an IPFS hash of an array containing all of the object's insertions and deletions.\n   * @return {Array<Array<any>>}\n   */\n  async ipfsSync() {\n    if (!this.active) {\n      return;\n    }\n    try {\n      const hash = await this.getIpfsHash();\n      if (!this.active) {\n        return;\n      }\n      if (!this.syncCache.has(hash, true) || this.hasNewPeers) {\n        this.syncCache.set(hash, true);\n        const { controller, cleanup } = this.createLinkedAbortController();\n        try {\n          await this.ipfs.pubsub.publish(`${this.topic}:hash`, Buffer.from(hash, 'utf8'), { signal: controller.signal });\n          this.emit('hash', hash);\n        } finally {\n          cleanup();\n        }\n      }\n      this.hasNewPeers = false;\n    } catch (error) {\n      if (error.type !== 'aborted' && this.active) {\n        this.emit('error', error);\n      }\n    }\n  }\n\n\n  /**\n   * Stores and returns an IPFS hash of the current insertions and deletions\n   * @return {Promise<string>}\n   */\n  async getIpfsHash():Promise<string> {\n    if (this.ipfsHash) {\n      return this.ipfsHash;\n    }\n    const data = await this.dump();\n    const { controller, cleanup } = this.createLinkedAbortController();\n    try {\n      const file = await this.ipfs.add(Buffer.from(JSON.stringify(data)), { wrapWithDirectory: false, recursive: false, pin: false, signal: controller.signal });\n      this.ipfsHash = file.cid.toString();\n      return this.ipfsHash;\n    } finally {\n      cleanup();\n    }\n  }\n\n  /**\n   * Current number of IPFS pubsub peers.\n   * @return {number}\n   */\n  async ipfsPeerCount():Promise<number> {\n    const { controller, cleanup } = this.createLinkedAbortController();\n    try {\n      const peerIds = await this.ipfs.pubsub.peers(this.topic, { signal: controller.signal });\n      return peerIds.length;\n    } finally {\n      cleanup();\n    }\n  }\n\n  /**\n   * Gracefully shutdown\n   * @return {void}\n   */\n  async shutdown(): Promise<void> {\n    this.active = false;\n    // Catch exceptions here as pubsub is sometimes closed by process kill signals.\n    if (this.ipfsId) {\n      try {\n        const unsubscribeAbortController = new AbortController();\n        const timeout = setTimeout(() => {\n          unsubscribeAbortController.abort();\n        }, 5000);\n        await this.ipfs.pubsub.unsubscribe(this.topic, this.boundHandleQueueMessage, { signal: unsubscribeAbortController.signal });\n        if (!this.disableSync) {\n          await this.ipfs.pubsub.unsubscribe(`${this.topic}:hash`, this.boundHandleHashMessage, { signal: unsubscribeAbortController.signal });\n        }\n        clearTimeout(timeout);\n      } catch (error) {\n        if (!notSubscribedRegex.test(error.message)) {\n          this.abortController.abort();\n          this.abortController = new AbortController();\n          throw error;\n        }\n      }\n    }\n    await this.hashLoadQueue.onIdle();\n    this.abortController.abort();\n    this.abortController = new AbortController();\n    await this.deserializeTransform.onIdle();\n    this.serializeTransform.destroy();\n    this.deserializeTransform.destroy();\n    await super.shutdown();\n  }\n\n  async handleQueueMessage(message:{from:string, data:Buffer}) {\n    if (message.from === this.ipfsId) {\n      return;\n    }\n    if (!this.active) {\n      return;\n    }\n    if (this.chunkPubSub) {\n      this.deserializeTransform.write(message.data);\n    } else {\n      try {\n        const queue = JSON.parse(Buffer.from(message.data).toString('utf8'));\n        await this.processSigned(queue);\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n  }\n\n  handleHashMessage(message:{from:string, data:Buffer}) {\n    if (!this.active) {\n      return;\n    }\n    if (message.from === this.ipfsId) {\n      return;\n    }\n    if (!this.peersCache.has(message.from)) {\n      this.hasNewPeers = true;\n      this.peersCache.set(message.from, true);\n    }\n    const remoteHash = Buffer.from(message.data).toString('utf8');\n    if (this.syncCache.has(remoteHash)) {\n      return;\n    }\n    this.syncCache.set(remoteHash, true);\n    try {\n      this.hashLoadQueue.add(() => this.loadIpfsHash(remoteHash));\n    } catch (error) {\n      this.emit('error', error);\n    }\n  }\n\n  async loadIpfsHash(hash:string) {\n    const { controller, cleanup } = this.createLinkedAbortController();\n    try {\n      // $FlowFixMe\n      const stream = Readable.from(this.ipfs.cat(new CID(hash), { timeout: 30000, signal: controller.signal }));\n      const parser = jsonStreamParser();\n      const streamArray = jsonStreamArray();\n      const pipeline = stream.pipe(parser);\n      let arrayDepth = 0;\n      let streamState = 0;\n      let insertions = [];\n      let deletions = [];\n      streamArray.on('data', ({ value }) => {\n        if (streamState === 1) {\n          insertions.push(value);\n        } else if (streamState === 3) {\n          deletions.push(value);\n        }\n        if (insertions.length + deletions.length < 1000) {\n          return;\n        }\n        const i = insertions;\n        const d = deletions;\n        insertions = [];\n        deletions = [];\n        this.processSigned([i, d], true);\n      });\n      try {\n        await new Promise((resolve, reject) => {\n          stream.on('error', (error) => {\n            reject(error);\n          });\n          streamArray.on('error', (error) => {\n            reject(error);\n          });\n          pipeline.on('error', (error) => {\n            reject(error);\n          });\n          pipeline.on('end', () => {\n            resolve();\n          });\n          pipeline.on('data', (data) => {\n            const { name } = data;\n            if (name === 'startArray') {\n              arrayDepth += 1;\n              if (arrayDepth === 2) {\n                streamState += 1;\n              }\n            }\n            if (streamState === 1 || streamState === 3) {\n              streamArray.write(data);\n            }\n            if (name === 'endArray') {\n              if (arrayDepth === 2) {\n                streamState += 1;\n              }\n              arrayDepth -= 1;\n            }\n          });\n        });\n      } catch (error) {\n        if (error.type !== 'aborted' && this.active) {\n          this.emit('error', error);\n        }\n        return;\n      } finally {\n        stream.destroy();\n      }\n      this.processSigned([insertions, deletions]);\n      await this.signedProcessQueue.onIdle();\n    } finally {\n      cleanup();\n    }\n  }\n}\n"],"file":"signed-map.js"}